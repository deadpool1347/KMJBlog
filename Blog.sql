-- phpMyAdmin SQL Dump
-- version 4.7.7
-- https://www.phpmyadmin.net/
--
-- Хост: 127.0.0.1:3306
-- Время создания: Фев 10 2019 г., 17:44
-- Версия сервера: 5.6.38
-- Версия PHP: 5.5.38

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
SET AUTOCOMMIT = 0;
START TRANSACTION;
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;

--
-- База данных: `Blog`
--

-- --------------------------------------------------------

--
-- Структура таблицы `Article`
--

CREATE TABLE `Article` (
  `idArticle` int(11) NOT NULL,
  `name` varchar(200) NOT NULL,
  `content` text NOT NULL,
  `date` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `idUser` int(11) NOT NULL,
  `idTheme` int(11) NOT NULL,
  `img` varchar(150) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

--
-- Дамп данных таблицы `Article`
--

INSERT INTO `Article` (`idArticle`, `name`, `content`, `date`, `idUser`, `idTheme`, `img`) VALUES
(1, 'Одномерные массивы', 'Все простые типы данных, рассматриваемые ранее, имеют два характерных свойства: неделимость и упорядоченность их значений. Составные, или структурированные, типы данных задают множество сложных значений с одним общим именем. Существует несколько методов структурирования, каждый из которых отличается способом обращения к отдельным компонентам. В данном учебном пособии будут рассмотрены только два структурированных типа данных: регулярный тип (массивы) и строковый тип (строка).С понятием «массив» приходится встречаться при решении научно-технических, экономических задач обработки большого количества однотипных значений. Таким образом, массив – это упорядоченная последовательность данных, состоящая из фиксированного числа элементов, имеющих один и тот же тип, и обозначаемая одним именем.\r\nНазвание регулярный тип массивы получили за то, что в них объединены однородные элементы, упорядоченные (урегулированные) по индексам, определяющим положение каждого элементы в массиве. Массиву присваивается имя, посредством которого можно ссылаться на него, как на единое целое. Элементы, образующие массив, упорядочены так, что каждому элементу соответствует совокупность номеров (индексов), определяющих его место в общей последовательности. Индексы представляют собой выражения простого типа. Доступ к каждому отдельному элементу осуществляется обращением к имени массива с указанием индекса нужного элемента: <имя массива>[<индекс>].\r\nОписание массива определяет его имя, размер массива и тип данных. Общий вид описания массива:\r\nType <имя нового типа данных>=array[<тип индекса>] of <тип компонентов>;\r\nДалее, в перечне переменных указывается имя массива, и через двоеточие указывается имя нового типа данных. Массив может быть описан и без представления типа в разделе описания типов данных:Var <имя массива>: array [<тип индекса>] of <тип компонентов>;\r\n \r\nЧаще всего в качестве типа индекса используется интервальный целый тип.\r\nЛинейный (одномерный) массив – массив, у которого в описании задан только один индекс, если два индекса – то это двумерный массив и т.д. Одномерные массивы часто называют векторами, т.е. они представляют собой конечную последовательность пронумерованных элементов.\r\nПрисваивание начальных значений (заполнение массива) заключается в присваивании каждому элементу массива некоторого значения, заданного типа. Наиболее эффективно эта операция осуществляется при помощи оператора for. Ввод данных может осуществляться: с клавиатуры, при помощи различных формул, в том числе и датчика случайных чисел.Индексированные элементы массива называются индексированными переменными и могут быть использованы так же, как и простые переменные. Например, они могут находиться в выражениях в качестве операндов, им можно присваивать любые значения, соответствующие их типу и т.д.\r\nАлгоритм решения задач с использованием массивов:\r\nОписание массива \r\nЗаполнение массива \r\nВывод (распечатка) массива \r\nВыполнение условий задачи \r\nВывод результата \r\nПример 1. Задан одномерный массив В(10), заполненный произвольным образом. Подсчитать количество элементов массива, больших заданного числа k.\r\nProgram massiv;\r\nUses crt; {очистка экрана}\r\nVar b:array [1..10] of integer;\r\nI, k, s: integer;\r\nBegin\r\nClrscr; S:=0;\r\nFor i:=1 to 10 do\r\nBegin\r\nWrite(‘Введите’, i, ‘-й элемент массива ’);\r\nReadln (B[i]);\r\nWrite(b[i], ‘ ‘);\r\nEnd;\r\nWrite(‘Введите число k’);\r\nReadln(k);\r\nFor i:=1 to 10 do\r\nIf b[i]>k then s:=s+1;\r\nWrite(‘Количество элементов’, s);\r\nEnd.\r\n \r\nПример 2. Определить самую высокую температуру и самый теплый день в мае.\r\nProgram massiv;\r\nUses crt; {очистка экрана}\r\nVar t:array [1..31] of integer;\r\nI, max, n: integer;\r\nBegin\r\nClrscr;\r\nFor i:=1 to 31 do\r\nBegin\r\nt[i]:=random(20);\r\nWrite(b[i], ‘ ‘);\r\nEnd;\r\nMax:=t[1]; n:=1;\r\nFor i:=2 to 31 do\r\nBegin\r\nIf t[i] > max then max:=t[i]; n:=i ;\r\nEnd;\r\nWrite(‘максимальная температура’, max, ‘в’, n, ‘день’);\r\nEnd.', '2018-12-31 21:00:00', 5, 1, ''),
(2, 'Класс', 'Класс — это элемент ПО, описывающий абстрактный тип данных и его частичную или полную реализацию. Другие абстрактные типы данных — метаклассы, интерфейсы, структуры, перечисления, — характеризуются какими-то своими, другими особенностями. Наряду с понятием «объекта» класс является ключевым понятием в ООП (хотя существуют и бесклассовые объектно-ориентированные языки, например, Self, Lua; подробнее смотрите Прототипное программирование). Суть отличия классов от других абстрактных типов данных состоит в том, что при задании типа данных класс определяет одновременно как интерфейс, так и реализацию для всех своих экземпляров, а вызов метода-конструктора обязателен. Точный смысл этой фразы будет раскрыт ниже.\r\n\r\nНа практике объектно-ориентированное программирование сводится к созданию некоторого количества классов, включая интерфейс и реализацию, и последующему их использованию. Графическое представление некоторого количества классов и связей между ними называется диаграммой классов. Объектно-ориентированный подход за время своего развития накопил множество рекомендаций (паттернов) по созданию классов и иерархий классов.\r\n\r\nИдея классов пришла из работ по базам знаний, имеющих отношение к исследованиям по искусственному интеллекту. Используемые человеком классификации в зоологии, ботанике, химии, деталях машин, несут в себе основную идею, что любую вещь всегда можно представить частным случаем некоторого более общего понятия. Конкретное яблоко — это в целом некоторое яблоко, вообще яблоко, а любое вообще яблоко — фрукт. Именно поэтому примеры классов в учебных пособиях по объектно-ориентированному программированию так часто упоминают яблоки и груши.\r\n\r\nВезде далее слова «класс», «объект», «интерфейс» и «структура» будут употребляться в своих специальных значениях, заданных в рамках ООП.\r\nКлассы и объекты, понятие экземпляра класса, понятие членов класса\r\nВ объектно-ориентированной программе с применением классов каждый объект является «экземпляром» некоторого конкретного класса, и других объектов не предусмотрено. То есть «экземпляр класса» в данном случае означает не «пример некоторого класса» или «отдельно взятый класс», а «объект, типом которого является какой-то класс». При этом в разных языках программирования допускается либо не допускается существование еще каких-то типов данных, экземпляры которых не являются объектами (то есть язык определяет, являются ли объектами такие вещи, как числа, массивы и указатели, или не являются, и, соответственно, есть ли такие классы как «число», «массив» или «указатель», экземплярами которых были бы каждое конкретное число, массив или указатель).\r\n\r\nНапример, абстрактный тип данных «строка текста» может быть оформлен в виде класса, и тогда все строки текста в программе будут являться объектами — экземплярами класса «строка текста».\r\n\r\nПри использовании классов все элементы кода программы, такие как переменные, константы, методы, процедуры и функции, могут принадлежать (а во многих языках обязаны принадлежать) тому или иному классу. Сам класс в итоге определяется как список своих членов, а именно полей (свойств) и методов/функций/процедур. В зависимости от языка программирования к этому списку могут добавиться константы, атрибуты и внешние определения.\r\n\r\nКак и структуры, классы могут задавать поля — то есть переменные, принадлежащие либо непосредственно самому классу (статические), либо экземплярам класса (обычные). Статические поля существуют в одном экземпляре на всю программу (или, в более сложном варианте, — в одном экземпляре на процесс или на поток/нить). Обычные поля создаются по одной копии для каждого конкретного объекта — экземпляра класса. Например, общее количество строк текста, созданных в программе за время её работы, будет являться статическим полем класса «строка текста». А конкретный массив символов строки будет являться обычным полем экземпляра класса «строка текста», так же как переменная «фамилия», имеющая тип «строка текста», будет являться обычным полем каждого конкретного экземпляра класса «человек».\r\n\r\nВ ООП при использовании классов весь исполняемый код программы (алгоритмы) будет оформляться в виде так называемых «методов», «функций» или «процедур», что соответствует обычному структурному программированию, однако теперь они могут (а во многих языках обязаны) принадлежать тому или иному классу. Например, по возможности, класс «строка текста» будет содержать все основные методы/функции/процедуры, предназначенные для работы со строкой текста, такие как поиск в строке, вырезание части строки и т. д.\r\n\r\nКак и поля, код в виде методов/функций/процедур, принадлежащих классу, может быть отнесен либо к самому классу, либо к экземплярам класса. Метод, принадлежащий классу и соотнесенный с классом (статический метод) может быть вызван сам по себе и имеет доступ к статическим переменным класса. Метод, соотнесенный с экземпляром класса (обычный метод), может быть вызван только у самого объекта, и имеет доступ как к статическим полям класса, так и к обычным полям конкретного объекта (при вызове этот объект передастся скрытым параметром метода). Например, общее количество созданных строк можно узнать из любого места программы, но длину конкретной строки можно узнать только указав, тем или иным образом, длину какой строки будем мерить.\r\n\r\nИнтерфейс и реализация, наследование реализации\r\nВ программировании есть понятие программного интерфейса, означающего перечень возможных вычислений, которые может выполнить та или иная часть программы. Это включает описание: какие аргументы и в каком порядке требуется передавать на вход алгоритмам из перечня, а также что и в каком виде они будут возвращать. Абстрактный тип данных интерфейс придуман для формализованного описания такого перечня. Сами алгоритмы, то есть действительный программный код, который будет выполнять все эти вычисления, интерфейсом не задаётся, программируется отдельно и называется реализацией интерфейса.\r\n\r\nПрограммные интерфейсы, а также классы, могут расширяться путём наследования, которое является одним из важных средств повторного использования готового кода в ООП. Наследованный класс или интерфейс будет содержать в себе всё, что указано для всех его родительских классов (в зависимости от языка программирования и платформы, их может быть от нуля до бесконечности). Например, можно создать свой вариант текстовой строки путём наследования класса «моя строка текста» от уже существующего класса «строка текста», при этом предполагается, что программисту не придется заново переписывать алгоритмы поиска и прочее, так как они автоматически будут унаследованы от готового класса, и любой экземпляр класса «моя строка текста» может быть передан не только в готовые методы родительского класса «строка текста» для проведения нужных вычислений, но и вообще в любой алгоритм, способный работать с объектами типа «строка текста», так как экземпляры обоих классов совместимы по программным интерфейсам.\r\n\r\nКласс позволяет задать не только программный интерфейс к самому себе и к своим экземплярам, но и в явном виде написать код, ответственный за вычисления. Если при создании своего нового типа данных наследовать интерфейс, то мы получим возможность передавать экземпляр своего типа данных в любой алгоритм, который умеет работать с этим интерфейсом. Однако нам придется самим написать реализацию интерфейса, то есть те алгоритмы, которыми будет пользоваться интересующий нас алгоритм для проведения вычислений с использованием нашего экземпляра. В то же время, наследуя класс, мы автоматически наследуем готовый код под интерфейс (это не всегда так, родительский класс может требовать реализации каких-то алгоритмов в дочернем классе в обязательном порядке). В этой возможности наследовать готовый код и проявляется то, что в объектно-ориентированной программе тип данных класс определяет одновременно и интерфейс, и реализацию для всех своих экземпляров.\r\n\r\nСостояние объекта, понятие областей доступа, конструкторы\r\nОдной из проблем структурного программирования, с которой борется ООП, является проблема поддержания правильного значения переменных программы. Часто разные переменные программы хранят логически связанные значения, и за поддержание этой логической связности несет ответственность программист, то есть автоматически связность не поддерживается. Примером могут служить флажки «уволен» и «ожидает премии по итогам года», когда по правилам отдела кадров человек может быть одновременно не уволенным и не ожидающим премии, не уволенным и ожидающим премии, уволенным и не ожидающим премии, но не может быть одновременно и уволенным, и ожидающим премии. То есть любая часть программы, которая проставляет флажок «уволен», всегда должна снимать флажок «ожидает премии по итогам года».\r\n\r\nХороший способ решить эту проблему — объявить флажок «уволен» недоступным к изменению для всех участков программы, кроме одного специально оговоренного. В этом специально оговоренном участке всё будет написано один раз и правильно, а все остальные должны будут обращаться к этому участку всегда, когда они хотят установить или снять флажок «уволен».\r\n\r\nВ объектно-ориентированной программе флажок «уволен» будет объявлен приватным членом некоторого класса, а для чтения и изменения его будут написаны соответствующие публичные методы. Правила, определяющие возможность или невозможность напрямую изменять какие-либо переменные, называются правилами задания областей доступа. Слова «приватный» и «публичный» в данном случае являются так называемыми «модификаторами доступа». Они называются модификаторами потому, что в некоторых языках они используются для изменения ранее установленных прав при наследовании класса. Совместно классы и модификаторы доступа задают область доступа, то есть у каждого участка кода, в зависимости от того, какому классу он принадлежит, будет своя область доступа относительно тех или иных элементов (членов) своего класса и других классов, включая переменные, методы, функции, константы и т. д. Существует основное правило: ничто в одном классе не может видеть приватных элементов другого класса. Относительно других, более сложных правил, в различных языках существуют другие модификаторы доступа и правила их взаимодействия с классами.\r\n\r\nПочти каждому члену класса можно установить модификатор доступа (за исключением статических конструкторов и некоторых других вещей). В большинстве объектно-ориентированных языков программирования поддерживаются следующие модификаторы доступа:\r\n\r\nprivate (закрытый, внутренний член класса) — обращения к члену допускаются только из методов того класса, в котором этот член определён. Любые наследники класса уже не смогут получить доступ к этому члену. Наследование по типу private делает все члены родительского класса (в том числе public и protected) private-членами класса-наследника (С++);\r\nprotected (защищённый, внутренний член иерархии классов) — обращения к члену допускаются из методов того класса, в котором этот член определён, а также из любых методов его классов-наследников. Наследование по типу protected делает все public-члены родительского класса protected-членами класса-наследника (С++);\r\npublic (открытый член класса) — обращения к члену допускаются из любого кода. Наследование по типу public не меняет модификаторов родительского класса (С++);\r\nПроблема поддержания правильного состояния переменных актуальна и для самого первого момента выставления начальных значений. Для этого в классах предусмотрены специальные методы/функции, называемые конструкторами. Ни один объект (экземпляр класса) не может быть создан иначе, как путём вызова на исполнение кода конструктора, который вернет вызывающей стороне созданный и правильно заполненный экземпляр класса. Во многих языках программирования тип данных «структура», как и класс, может содержать переменные и методы, но экземпляры структур, оставаясь просто размеченным участком оперативной памяти, могут создаваться в обход конструкторов, что запрещено для экземпляров классов (за исключением специальных исключительных методов обхода всех подобных правил ООП, предусмотренных в некоторых языках и платформах). В этом проявляется отличие классов от других типов данных — вызов конструктора обязателен.\r\n\r\nПрактический подход\r\nВ современных объектно-ориентированных языках программирования (в том числе в php, Java, C++, Oberon, Python, Ruby, Smalltalk, Object Pascal) создание класса сводится к написанию некоторой структуры, содержащей набор полей и методов (среди последних особую роль играют конструкторы, деструкторы, финализаторы). Практически класс может пониматься как некий шаблон, по которому создаются объекты — экземпляры данного класса. Все экземпляры одного класса созданы по одному шаблону, поэтому имеют один и тот же набор полей и методов.\r\n\r\nОтношения между классами\r\nНаследование (Генерализация) — объекты дочернего класса наследуют все свойства родительского класса.\r\nАссоциация — объекты классов вступают во взаимодействие между собой.\r\nАгрегация — объекты одного класса входят в объекты другого.\r\nКомпозиция — объекты одного класса входят в объекты другого и зависят друг от друга по времени жизни.\r\nКласс-Метакласс — отношение, при котором экземплярами одного класса являются другие классы.\r\nВиды классов\r\nСм. также: Наследование (программирование)\r\nБазовый (родительский) класс\r\nПроизводный класс (наследник, потомок)\r\nАбстрактный класс\r\nИнтерфейс\r\nОбласть видимости\r\nОбласть видимости членов класса (то есть область кода, из которой к ним можно обращаться по неквалифицированному имени — без указания имени класса или объекта) не зависит от их области доступа, и всегда совпадает с кодом методов класса.\r\n\r\nОбласть видимости самого класса по-разному определяется в разных языках программирования. В одних языках (таких как Delphi) все классы имеют глобальную видимость (с учётом видимости модуля), в других (таких как Java) область видимости класса связана с содержащей его единицей компиляции (в Java — с пакетом), в третьих (таких как C++ и C#) область видимости класса определяется пространствами имён (namespaces), которые задаются программистом явно и могут совпадать или не совпадать с единицами компиляции.', '2018-12-31 21:00:00', 5, 2, ''),
(18, 'Основное понятие неравенства', 'Неравенство [inequality] — соотношение между числами (или любыми математическими выражениями, способными принимать численное значение), указывающее, какое из них больше или меньше другого. Над этими выражениями можно по определенным правилам производить следующие действия: сложение, вычитание, умножение и деление (причем при умножении или делении Н. на отрицательное число смысл его меняется на противоположный). Одно из основных понятий линейного программирования — линейные неравенства вида\r\na 1x 1 + a 2x 2 +… + an xn * b ,\r\nгде a 1 ,..., an, b — постоянные и знак * — один из знаков неравенства, напр. ≥, <, ≤.\r\nВ матричной алгебре знак ≥ означает что все элементы матрицы, расположенной слева, не меньше (а хотя бы часть из них больше) соответствующих элементов матрицы, расположенной справа. В отличие от этого знак ≤ означает, что все элементы левой матрицы не меньше соответствующих элементов правой матрицы; в частности, все соответствующие элементы могут быть попарно равны. (Иногда применяются и другие обозначения.)\r\nКлассификация неравенств\r\nНеравенства, содержащие неизвестные величины, подразделяются на:[1]\r\n· алгебраические \r\n· трансцендентные \r\nАлгебраические неравенства подразделяются на неравенства первой, второй, и т. д. степени.\r\nПример: \r\nНеравенство — алгебраическое, второй степени. \r\nНеравенство — трансцендентное. ', '2019-01-21 09:28:54', 20, 4, ''),
(19, 'Вашкевич М.А.', 'sq', '2019-01-21 09:29:49', 20, 2, ''),
(20, 'Вашкевич М.А.', 'jbnmkl;[lpknjbhnjkml;mknb nmkl', '2019-01-21 09:53:33', 20, 2, ''),
(21, 'Вашкевич М.А.', 'dwseq', '2019-01-21 09:54:49', 20, 4, ''),
(22, 'Вашкевич М.А.', 'dfgfdgfhj', '2019-01-21 09:56:55', 20, 1, 'img-1548064615860.jpg'),
(23, 'htththth', 'hrthrthdtht', '2019-01-22 09:28:28', 20, 1, 'img-1548149308032.jpg'),
(24, 'Вашкевич М.А.', 'eknjbhvgcwvhbjkl;2kjbhvgcvjkl;kjhbvgcfxfhjkl;v bjkljhvc', '2019-01-22 09:30:53', 20, 1, ''),
(25, 'tag123456789098765432345678', '1234567u8i9i87654323456y7uiu7654ewaxc ', '2019-01-22 10:23:12', 20, 4, 'undefined');

-- --------------------------------------------------------

--
-- Структура таблицы `ArticleLike`
--

CREATE TABLE `ArticleLike` (
  `idArticleLike` int(11) NOT NULL,
  `idArticle` int(11) NOT NULL,
  `likes` int(11) DEFAULT NULL,
  `idUser` int(11) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

--
-- Дамп данных таблицы `ArticleLike`
--

INSERT INTO `ArticleLike` (`idArticleLike`, `idArticle`, `likes`, `idUser`) VALUES
(1, 24, 1, 5),
(2, 24, 1, 20),
(16, 18, 1, 20),
(21, 22, 1, 20),
(22, 23, 1, 20),
(23, 25, 1, 20),
(24, 2, 1, 20),
(25, 1, 1, 20),
(26, 19, 1, 20),
(27, 20, 1, 20),
(28, 21, 1, 20);

-- --------------------------------------------------------

--
-- Структура таблицы `Comment`
--

CREATE TABLE `Comment` (
  `idComment` int(11) NOT NULL,
  `content` varchar(200) NOT NULL,
  `date` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `idArticle` int(11) NOT NULL,
  `idUser` int(11) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

--
-- Дамп данных таблицы `Comment`
--

INSERT INTO `Comment` (`idComment`, `content`, `date`, `idArticle`, `idUser`) VALUES
(1, 'Коментарии………...', '2018-12-31 21:00:00', 2, 5),
(3, 'КОментарий2', '2018-12-31 21:00:00', 2, 6),
(4, 'hello', '0000-00-00 00:00:00', 2, 20),
(5, 'hello', '0000-00-00 00:00:00', 2, 20),
(6, 'rgfedwsa', '2019-01-25 10:58:19', 1, 20),
(7, 'wcsqvhabnmkjwbn ', '2019-01-25 10:58:32', 1, 20);

-- --------------------------------------------------------

--
-- Структура таблицы `Status`
--

CREATE TABLE `Status` (
  `idStatus` int(11) NOT NULL,
  `name` varchar(100) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

--
-- Дамп данных таблицы `Status`
--

INSERT INTO `Status` (`idStatus`, `name`) VALUES
(1, 'inactiveUser'),
(2, 'user'),
(3, 'author'),
(4, 'admin');

-- --------------------------------------------------------

--
-- Структура таблицы `Subject`
--

CREATE TABLE `Subject` (
  `idSubject` int(11) NOT NULL,
  `name` varchar(200) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

--
-- Дамп данных таблицы `Subject`
--

INSERT INTO `Subject` (`idSubject`, `name`) VALUES
(1, 'Информатика'),
(2, 'Математика');

-- --------------------------------------------------------

--
-- Структура таблицы `Tag`
--

CREATE TABLE `Tag` (
  `idTag` int(11) NOT NULL,
  `name` varchar(100) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

--
-- Дамп данных таблицы `Tag`
--

INSERT INTO `Tag` (`idTag`, `name`) VALUES
(1, 'Таг1'),
(2, 'Таг2');

-- --------------------------------------------------------

--
-- Структура таблицы `TagArticle`
--

CREATE TABLE `TagArticle` (
  `idTagArticle` int(11) NOT NULL,
  `idTag` int(11) NOT NULL,
  `idArticle` int(11) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

--
-- Дамп данных таблицы `TagArticle`
--

INSERT INTO `TagArticle` (`idTagArticle`, `idTag`, `idArticle`) VALUES
(1, 1, 1),
(2, 2, 2),
(3, 2, 5),
(4, 1, 15),
(5, 1, 16),
(6, 1, 17),
(7, 2, 17),
(8, 1, 19),
(9, 1, 20),
(10, 2, 20),
(11, 1, 21),
(12, 2, 21),
(13, 1, 22),
(14, 2, 22),
(15, 2, 23),
(16, 1, 24),
(17, 1, 25),
(18, 2, 25);

-- --------------------------------------------------------

--
-- Структура таблицы `Theme`
--

CREATE TABLE `Theme` (
  `idTheme` int(11) NOT NULL,
  `name` varchar(200) NOT NULL,
  `idSubject` int(11) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

--
-- Дамп данных таблицы `Theme`
--

INSERT INTO `Theme` (`idTheme`, `name`, `idSubject`) VALUES
(1, 'Одномерные массивы', 1),
(2, 'Класс', 1),
(4, 'Неравенства', 2);

-- --------------------------------------------------------

--
-- Структура таблицы `Training`
--

CREATE TABLE `Training` (
  `idTtraining` int(11) NOT NULL,
  `idArticle` int(11) NOT NULL,
  `url` varchar(40) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

--
-- Дамп данных таблицы `Training`
--

INSERT INTO `Training` (`idTtraining`, `idArticle`, `url`) VALUES
(1, 2, 'ссылка1'),
(2, 2, 'ссылка2'),
(3, 1, 'ссылка1'),
(4, 2, 'ссылка2');

-- --------------------------------------------------------

--
-- Структура таблицы `User`
--

CREATE TABLE `User` (
  `idUser` int(11) NOT NULL,
  `login` varchar(60) NOT NULL,
  `nickname` varchar(15) NOT NULL,
  `password` varchar(25) NOT NULL,
  `date` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `idStatus` int(11) NOT NULL,
  `keyCode` int(10) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

--
-- Дамп данных таблицы `User`
--

INSERT INTO `User` (`idUser`, `login`, `nickname`, `password`, `date`, `idStatus`, `keyCode`) VALUES
(5, 'nkh@bdje.ru', '', 'ycgew', '2018-12-09 21:00:00', 1, 0),
(6, 'urhfe@eyru.ru', '', 'gfyeh', '2018-12-29 21:00:00', 2, 0),
(9, 'name', '', 'pswd', '0000-00-00 00:00:00', 2, 567833),
(11, 'p_m.a.vashkevich@mpt.ru', '', '1', '2019-01-10 12:03:37', 1, 543878568),
(20, 'fuurria@yandex.ru', '', '2', '2019-01-14 10:38:24', 3, 396681638),
(21, 'test@yandex.ru', 'test', '12', '2019-02-10 11:26:25', 1, 964180904),
(22, 'test@yandex.ru', 'test', '12', '2019-02-10 12:01:50', 1, 379080332);

-- --------------------------------------------------------

--
-- Структура таблицы `UserInfo`
--

CREATE TABLE `UserInfo` (
  `idUser` int(11) NOT NULL,
  `name` varchar(25) NOT NULL,
  `vk` varchar(50) NOT NULL,
  `facebook` varchar(50) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

--
-- Дамп данных таблицы `UserInfo`
--

INSERT INTO `UserInfo` (`idUser`, `name`, `vk`, `facebook`) VALUES
(5, 'ник1', 'url vk1', 'url facebook1'),
(6, 'ник2', 'url vk 2', 'url facebook 2');

-- --------------------------------------------------------

--
-- Структура таблицы `Video`
--

CREATE TABLE `Video` (
  `idVideo` int(11) NOT NULL,
  `idArticle` int(11) NOT NULL,
  `url` varchar(50) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

--
-- Дамп данных таблицы `Video`
--

INSERT INTO `Video` (`idVideo`, `idArticle`, `url`) VALUES
(1, 2, 'url1'),
(2, 1, 'url1'),
(3, 2, 'url2'),
(4, 1, 'url2');

--
-- Индексы сохранённых таблиц
--

--
-- Индексы таблицы `Article`
--
ALTER TABLE `Article`
  ADD PRIMARY KEY (`idArticle`),
  ADD KEY `idUser` (`idUser`),
  ADD KEY `idTheme` (`idTheme`);

--
-- Индексы таблицы `ArticleLike`
--
ALTER TABLE `ArticleLike`
  ADD PRIMARY KEY (`idArticleLike`),
  ADD KEY `idArticle` (`idArticle`),
  ADD KEY `idUser` (`idUser`);

--
-- Индексы таблицы `Comment`
--
ALTER TABLE `Comment`
  ADD PRIMARY KEY (`idComment`),
  ADD KEY `idUser` (`idUser`),
  ADD KEY `idArticle` (`idArticle`);

--
-- Индексы таблицы `Status`
--
ALTER TABLE `Status`
  ADD PRIMARY KEY (`idStatus`);

--
-- Индексы таблицы `Subject`
--
ALTER TABLE `Subject`
  ADD PRIMARY KEY (`idSubject`);

--
-- Индексы таблицы `Tag`
--
ALTER TABLE `Tag`
  ADD PRIMARY KEY (`idTag`);

--
-- Индексы таблицы `TagArticle`
--
ALTER TABLE `TagArticle`
  ADD PRIMARY KEY (`idTagArticle`),
  ADD KEY `idTag` (`idTag`) USING BTREE,
  ADD KEY `idArticle` (`idArticle`);

--
-- Индексы таблицы `Theme`
--
ALTER TABLE `Theme`
  ADD PRIMARY KEY (`idTheme`),
  ADD KEY `idSubject` (`idSubject`) USING BTREE;

--
-- Индексы таблицы `Training`
--
ALTER TABLE `Training`
  ADD PRIMARY KEY (`idTtraining`),
  ADD KEY `idArticle` (`idArticle`);

--
-- Индексы таблицы `User`
--
ALTER TABLE `User`
  ADD PRIMARY KEY (`idUser`),
  ADD KEY `idStatus` (`idStatus`) USING BTREE;

--
-- Индексы таблицы `UserInfo`
--
ALTER TABLE `UserInfo`
  ADD KEY `idUser` (`idUser`);

--
-- Индексы таблицы `Video`
--
ALTER TABLE `Video`
  ADD PRIMARY KEY (`idVideo`),
  ADD KEY `idArticle` (`idArticle`);

--
-- AUTO_INCREMENT для сохранённых таблиц
--

--
-- AUTO_INCREMENT для таблицы `Article`
--
ALTER TABLE `Article`
  MODIFY `idArticle` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=26;

--
-- AUTO_INCREMENT для таблицы `ArticleLike`
--
ALTER TABLE `ArticleLike`
  MODIFY `idArticleLike` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=29;

--
-- AUTO_INCREMENT для таблицы `Comment`
--
ALTER TABLE `Comment`
  MODIFY `idComment` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=8;

--
-- AUTO_INCREMENT для таблицы `Status`
--
ALTER TABLE `Status`
  MODIFY `idStatus` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=5;

--
-- AUTO_INCREMENT для таблицы `Subject`
--
ALTER TABLE `Subject`
  MODIFY `idSubject` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=3;

--
-- AUTO_INCREMENT для таблицы `Tag`
--
ALTER TABLE `Tag`
  MODIFY `idTag` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=3;

--
-- AUTO_INCREMENT для таблицы `TagArticle`
--
ALTER TABLE `TagArticle`
  MODIFY `idTagArticle` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=19;

--
-- AUTO_INCREMENT для таблицы `Theme`
--
ALTER TABLE `Theme`
  MODIFY `idTheme` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=5;

--
-- AUTO_INCREMENT для таблицы `Training`
--
ALTER TABLE `Training`
  MODIFY `idTtraining` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=5;

--
-- AUTO_INCREMENT для таблицы `User`
--
ALTER TABLE `User`
  MODIFY `idUser` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=23;

--
-- AUTO_INCREMENT для таблицы `Video`
--
ALTER TABLE `Video`
  MODIFY `idVideo` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=5;

--
-- Ограничения внешнего ключа сохраненных таблиц
--

--
-- Ограничения внешнего ключа таблицы `Article`
--
ALTER TABLE `Article`
  ADD CONSTRAINT `article_ibfk_1` FOREIGN KEY (`idUser`) REFERENCES `User` (`idUser`),
  ADD CONSTRAINT `article_ibfk_2` FOREIGN KEY (`idTheme`) REFERENCES `Theme` (`idTheme`);

--
-- Ограничения внешнего ключа таблицы `ArticleLike`
--
ALTER TABLE `ArticleLike`
  ADD CONSTRAINT `articlelike_ibfk_1` FOREIGN KEY (`idArticle`) REFERENCES `Article` (`idArticle`);

--
-- Ограничения внешнего ключа таблицы `Comment`
--
ALTER TABLE `Comment`
  ADD CONSTRAINT `comment_ibfk_1` FOREIGN KEY (`idArticle`) REFERENCES `Article` (`idArticle`),
  ADD CONSTRAINT `comment_ibfk_2` FOREIGN KEY (`idUser`) REFERENCES `User` (`idUser`);

--
-- Ограничения внешнего ключа таблицы `Theme`
--
ALTER TABLE `Theme`
  ADD CONSTRAINT `theme_ibfk_1` FOREIGN KEY (`idSubject`) REFERENCES `Subject` (`idSubject`);

--
-- Ограничения внешнего ключа таблицы `Training`
--
ALTER TABLE `Training`
  ADD CONSTRAINT `training_ibfk_1` FOREIGN KEY (`idArticle`) REFERENCES `Article` (`idArticle`);

--
-- Ограничения внешнего ключа таблицы `User`
--
ALTER TABLE `User`
  ADD CONSTRAINT `user_ibfk_1` FOREIGN KEY (`idStatus`) REFERENCES `Status` (`idStatus`);

--
-- Ограничения внешнего ключа таблицы `UserInfo`
--
ALTER TABLE `UserInfo`
  ADD CONSTRAINT `userinfo_ibfk_1` FOREIGN KEY (`idUser`) REFERENCES `User` (`idUser`) ON DELETE CASCADE;

--
-- Ограничения внешнего ключа таблицы `Video`
--
ALTER TABLE `Video`
  ADD CONSTRAINT `video_ibfk_1` FOREIGN KEY (`idArticle`) REFERENCES `Article` (`idArticle`);
COMMIT;

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
